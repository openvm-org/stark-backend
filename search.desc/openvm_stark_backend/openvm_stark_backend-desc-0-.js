searchState.loadedDescShard("openvm_stark_backend", 0, "Backend for proving and verifying mixed-matrix STARKs. The …\nA chip is a stateful struct that stores the state …\nA trait to get chip usage information.\nAIR builders for prover and verifier, including support …\nAPI trait for circuit prover/verifier.\nTypes for tracking matrix in system with multiple …\nHelper types associated to generic STARK config. …\nIf the chip has a state-independent trace height that is …\nIf the chip has a state-independent trace height that is …\nFor metrics collection\nFor metrics collection\nHeight of used rows in the main trace.\nTrait for STARK backend engine proving keygen, proviing, …\nGenerate all necessary input for proving a single AIR.\nGKR batch prover for Grand Product and LogUp lookup …\nLog-up permutation argument implementation as RAP.\nProving and verifying key generation\nPolynomials\nProver implementation for partitioned multi-matrix AIRs.\nTrait for RAP (Randomized AIR with Preprocessing)\nSum-check protocol that proves and verifies claims about …\nWidth of the main trace\nUtility functions\nVerifier implementation\nAIR builder that supports main trace matrix which is …\nCached main trace matrix.\nCommon main trace matrix. Panic if there is no common main …\nAn <code>AirBuilder</code> which asserts that each constraint is zero, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIt is difficult to horizontally concatenate matrices when …\nCheck that all constraints vanish on the subgroup.\nA folder for prover constraints.\nReturns the argument unchanged.\nNumber of interactions to bundle in permutation trace, if …\nCalls <code>U::from(self)</code>.\nIt is difficult to horizontally concatenate matrices when …\nA builder used to eval a sub-air.  This will handle …\nA submatrix of a matrix.  The matrix will contain a subset …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSymbolic constraints for a single AIR with interactions. …\nAn <code>AirBuilder</code> for evaluating constraints symbolically, and …\nAll constraints of the RAP, including the constraints on …\nReturns the argument unchanged.\nReturns the argument unchanged.\nOnly for debug purposes. <code>constraints</code> also contains the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIt is difficult to horizontally concatenate matrices when …\nReturns the maximum field degree and count degree across …\nAn expression over <code>SymbolicVariable</code>s.\nReturns the multiple of <code>n</code> (the trace length) in this …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMain may be partitioned\nA variable within the evaluation window, i.e. a column in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdvance the internal offset of the entry by the given …\nA folder for verifier constraints with generic types.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAsync prover for a specific circuit using a specific Stark …\nProver for a specific circuit using a specific Stark …\nVerifier for a specific circuit using a specific Stark …\nThe PCS commits to multiple matrices at once, so this …\nIn a multi-matrix system, we record a pointer from each …\nWhen a single matrix belong to a multi-matrix commitment …\nProver data, includes LDE matrix of trace and Merkle tree. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe index of the trace matrix in the prover data.\nFor each matrix, the pointer\nThe field from which most random challenges are drawn.\nThe challenger (Fiat-Shamir) implementation used.\nThe PCS used to commit to trace polynomials.\nThe RAP challenge phases used to establish, e.g., that …\nBased on p3_uni_stark::StarkGenericConfig.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTesting engine\nData for verifying a Stark proof.\nStark config\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new challenger with a deterministic state. …\nRuns a single end-to-end test for a given set of AIRs and …\nRuns a single end-to-end test for a given set of chips and …\nAdd AIRs and get AIR IDs\nThe circuit polynomial the verifier evaluated doesn’t …\nDefines how a circuit operates locally on two input rows …\nValues of interest obtained from the execution of the GKR …\nBatch GKR proof.\nError encountered during GKR protocol verification.\nStores two evaluations of each column in a GKR layer.\nMask has an invalid number of columns.\nError indicating the mask has an invalid number of columns …\nThere was an error with one of the sumcheck proofs.\nRepresents a layer in a binary tree structured GKR circuit.\nGKR layer index where 0 corresponds to the output layer.\nAll numerators implicitly equal “1”.\nThe proof is malformed.\nError returned when a polynomial is expected to be …\nThere is a mismatch between the number of instances in the …\nThe claimed evaluation at <code>ood_point</code> for each column in the …\nComputes <code>r(t) = sum_x eq((t, x), y[-k:]) * p(t, x)</code> from …\nReturns a transformed layer with the first variable of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMask for each layer for each instance.\nReturns the number of variables used to interpolate the …\nThe number of variables that interpolate the input layer …\nProduces the next layer from the current layer.\nOut-of-domain (OOD) point for evaluating columns in the …\nColumn circuit outputs for each instance.\nPartially verifies a batch GKR proof.\nBatch proves lookup circuits with GKR.\nReturns all <code>p_i(x)</code> where <code>p_i</code> interpolates column <code>i</code> of the …\nSum-check proof for each layer.\nReturns each column output if the layer is an output …\nLayer of the instance (but not necessarily the batch).\nAn AirBuilder with additional functionality to build …\nDefines a particular protocol for the “after challenge”…\nSupported challenge phases in a RAP.\nUp to one phase with prover/verifier given by […\nAfter challenge trace per air computed as a function of …\nReturns all interactions stored.\nChallenges from the challenger in this phase that …\nChallenges from the challenger in this phase that …\nInteraction debugging tools\nPublic values of the phase that are functions of <code>challenges</code>…\nAny additional rotations to open at in the permutation PCS …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe protocol parameters for the challenge phases may …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the current number of interactions.\nPartially prove the challenge phases,\nPartially verifies the challenge phases.\nStores a new interaction in the builder.\nStores a new receive interaction in the builder.\nStores a new send interaction in the builder.\nAn AIR with specified interactions can be augmented into a …\nThe actual interactions that are sent/received during a …\nBus index =&gt; (fields =&gt; (air_idx, interaction_type, count))\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe permutation row consists of 1 column for each bundle …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate the permutation trace for a chip given the main …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStateful builder to create multi-stark proving and …\nDefault way to add a single Interactive AIR. Returns <code>air_id</code>\nReturns the argument unchanged.\nConsume the builder and generate proving key. The …\nCalls <code>U::from(self)</code>.\nCommon proving key for multiple AIRs.\nCommon verifying key for multiple AIRs.\nProver only data for preprocessed trace for a single AIR. …\nProving key for a single STARK (corresponding to single …\nVerifying key for a single STARK (corresponding to single …\nWidths of different parts of trace matrix\nVerifier data for preprocessed trace for a single AIR.\nWidth counted by extension field elements, <em>not</em> base field …\nType name of the AIR, for display purposes only\nCommitment to the preprocessed trace.\nProver data, such as a Merkle tree, for the trace …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the widths of all main traces, including the …\nMaximum degree of constraints (excluding logup …\nFor only this RAP, how many challenges are needed in each …\nNumber of values to expose to verifier in each trace …\nNumber of public values for this STARK only\nParameters of the STARK\nPreprocessed trace data, if any\nProver only data for preprocessed trace\nThe factor to multiple the trace degree by to get the …\nSymbolic constraints of the AIR in all challenge phases. …\nPreprocessed trace matrix.\nVerifying key\nTrace sub-matrix widths\nCopied from starkware-libs/stwo under Apache-2.0 license.\nCopied from starkware-libs/stwo under Apache-2.0 license.\nMultilinear extension of the function defined on the …\nRepresents a multivariate polynomial <code>g(x_1, ..., x_n)</code>.\nFor an n-variate polynomial, returns n.\nComputes …\nReturns the argument unchanged.\nEvaluates the boolean Lagrange basis polynomial <code>eq(x, y)</code>.\nCalls <code>U::from(self)</code>.\nReturns the sum of <code>g(x_1, x_2, ..., x_n)</code> over all …\nCreates a <code>Mle</code> from evaluations of a multilinear polynomial …\nReturns the multivariate polynomial …\nProjective fraction.\nEvaluates a polynomial represented by coefficients in a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new univariate polynomial from a vector of …\nInterpolates <code>points</code> via Lagrange interpolation.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>v_0 + alpha * v_1 + ... + alpha^(n-1) * v_{n-1}</code>.\nProves multiple chips with interactions together. This …\nA view of just the preprocessed AIR, without any after …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMetrics about trace and other statistics related to prover …\nPolynomial opening proofs\nSpecialized prove for InteractiveAirs. Handles trace …\nComputation of DEEP quotient polynomial and commitment\nTest helper trait for AirProofInput Don’t use this trait …\nTrace cells, counted in terms of number of <strong>base field</strong> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTotal base field cells from all traces, excludes …\nOmitting preprocessed trace, the total base field cells …\nheights are the trace heights for each air\nThe after challenge width is adjusted to be in terms of …\nPCS opening proof with opened values for multi-matrix AIR.\nFor each phase after challenge, there is shared commitment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFor each main trace commitment, for each matrix in …\nOpening proof for multiple RAP matrices, where\nFor each preprocessed trace commitment, the opened values\nFor each RAP, for each quotient chunk in quotient poly, …\nProver data for multi-matrix quotient polynomial …\nThe vector of evaluations of the quotient polynomial on …\nThe quotient polynomials from multiple RAP matrices.\nAll necessary data from VK to compute ProverQuotientData\nThe quotient polynomial from a single matrix RAP, …\nMatrix with number of rows equal to trace domain size, and …\nQuotient commitment\nProver data for the quotient commitment\nChunk of quotient domain, which is a coset of the trace …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFor each AIR, the number of quotient chunks that were …\nConstructs quotient domains and computes the evaluation of …\nSplits the quotient polynomials from multiple AIRs into …\nThe vector of evaluations of the quotient polynomial on …\nSymbolic constraints of the AIR in all challenge phases. …\nComputes evaluation of DEEP quotient polynomial on the …\nNecessary input for proving a single AIR.\nRaw input for proving a single AIR.\nAll commitments to a multi-matrix STARK that are not …\nThe full proof for multiple RAPs where trace matrices are …\nProof input\nProver data for multi-matrix trace commitments. The data …\nProver that commits to a batch of trace matrices, possibly …\nOne shared commitment for all trace matrices across all …\nCached main trace matrices\nProver data for cached main traces\nUses the PCS to commit to a sequence of trace matrices. …\nCommitment to the trace matrices.\nThe PCS commitments\nCommon main trace matrix\nProver data, such as a Merkle tree, for the trace …\nheight of trace matrix.\nFor each challenge phase with trace, the values to expose …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMultiple commitments for the main trace. For each RAP, …\nReturn the height of the main trace.\nOpening proofs separated by partition, but this may change\n(AIR id, AIR input)\nProof data for each AIR\nPublic values\nShared commitment for all quotient polynomial evaluations\nPartial proof for rap phase if it exists\nRAP trait for all-purpose dynamic dispatch use. This trait …\nAn AIR with 0 or more public values. This trait will be …\nAn AIR with 1 or more main trace partitions.\nPermutation AIR builder that exposes certain values to …\nAn AIR that works with a particular <code>AirBuilder</code> which …\nBy default, an AIR has no cached main trace.\nBy default, an AIR has only one private main trace.\nAutomatically derives the AIR name from the type name for …\nName for display purposes\nMax degree of polynomials the verifier accepts in each …\nSum-check round index where 0 corresponds to the first …\nSum-check protocol verification error.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPartially verifies a sum-check proof.\nPerforms sum-check on a random linear combinations of …\nCalculates and returns the multiplicative inverses of each …\nDisables the debug builder so there are not debug assert …\nAn error occurred while verifying the claimed openings.\nVerifies a partitioned proof of multi-matrix AIRs.\nOut-of-domain evaluation mismatch, i.e. <code>constraints(zeta)</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVerify collection of InteractiveAIRs and check the …\nVerify general RAPs without checking any relations (e.g., …")